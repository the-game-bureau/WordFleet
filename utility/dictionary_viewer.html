<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dictionary Viewer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
        }

        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 30px;
            font-size: 2.5em;
            font-weight: 300;
            letter-spacing: -1px;
        }

        .upload-area {
            border: 3px dashed #667eea;
            border-radius: 16px;
            padding: 40px;
            text-align: center;
            margin-bottom: 30px;
            background: #f8f9ff;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .upload-area:hover {
            border-color: #764ba2;
            background: #f0f2ff;
        }

        .upload-area.dragover {
            border-color: #764ba2;
            background: #e8f0ff;
            transform: scale(1.02);
        }

        .upload-text {
            font-size: 1.2em;
            color: #667eea;
            margin-bottom: 15px;
            font-weight: 600;
        }

        .upload-hint {
            color: #7f8c8d;
            font-size: 0.9em;
        }

        #fileInput {
            display: none;
        }

        .controls {
            display: flex;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            align-items: center;
            justify-content: space-between;
        }

        .controls-left {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            align-items: center;
        }

        .controls-right {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .pagination {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .pagination button {
            padding: 8px 16px;
            border: 2px solid #667eea;
            border-radius: 8px;
            background: white;
            color: #667eea;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .pagination button:hover:not(:disabled) {
            background: #667eea;
            color: white;
        }

        .pagination button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            border-color: #bdc3c7;
            color: #bdc3c7;
        }

        .pagination .page-info {
            padding: 8px 16px;
            background: #f8f9fa;
            border-radius: 8px;
            color: #5a6c7d;
            font-weight: 600;
            min-width: 120px;
            text-align: center;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        label {
            font-weight: 600;
            color: #34495e;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        select, input[type="text"] {
            padding: 12px 16px;
            border: 2px solid #e1e8ed;
            border-radius: 12px;
            font-size: 16px;
            background: white;
            transition: all 0.3s ease;
            min-width: 150px;
        }

        select:focus, input[type="text"]:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .stats {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            font-size: 0.9em;
            color: #7f8c8d;
            flex-wrap: wrap;
        }

        .stat {
            padding: 8px 16px;
            background: #f8f9fa;
            border-radius: 20px;
            font-weight: 500;
        }

        .message {
            text-align: center;
            padding: 40px;
            color: #7f8c8d;
            font-size: 1.2em;
        }

        .error {
            background: #fee;
            border: 2px solid #fcc;
            color: #c33;
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 20px;
        }

        .success {
            background: #efe;
            border: 2px solid #cfc;
            color: #393;
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 20px;
        }

        .table-container {
            overflow-x: auto;
            border-radius: 16px;
            border: 1px solid #e1e8ed;
            background: white;
            max-height: 70vh;
            overflow-y: auto;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
        }

        th {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 16px 12px;
            text-align: left;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            cursor: pointer;
            user-select: none;
            position: sticky;
            top: 0;
            z-index: 10;
            transition: background 0.3s ease;
        }

        th:hover {
            background: linear-gradient(135deg, #5a6fd8, #6a42a0);
        }

        th.sortable::after {
            content: ' ‚Üï';
            opacity: 0.5;
            margin-left: 8px;
        }

        th.sort-asc::after {
            content: ' ‚Üë';
            opacity: 1;
        }

        th.sort-desc::after {
            content: ' ‚Üì';
            opacity: 1;
        }

        td {
            padding: 14px 12px;
            border-bottom: 1px solid #f1f3f4;
            vertical-align: top;
            line-height: 1.4;
        }

        tr:hover {
            background: #f8f9ff;
        }

        .word {
            font-weight: 700;
            color: #2c3e50;
            font-size: 1.1em;
            letter-spacing: 0.5px;
        }

        .definition {
            color: #5a6c7d;
            max-width: 400px;
            word-wrap: break-word;
        }

        .deck {
            background: #e8f4fd;
            color: #1976d2;
            padding: 4px 12px;
            border-radius: 16px;
            font-size: 0.85em;
            font-weight: 600;
            text-align: center;
            white-space: nowrap;
        }

        @media (max-width: 768px) {
            .container {
                padding: 20px;
                margin: 10px;
            }

            .controls {
                flex-direction: column;
                align-items: stretch;
            }

            .control-group {
                width: 100%;
            }

            select, input[type="text"] {
                min-width: unset;
                width: 100%;
            }

            h1 {
                font-size: 2em;
            }

            table {
                font-size: 12px;
            }

            th, td {
                padding: 10px 8px;
            }

            .definition {
                max-width: 200px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üìö Dictionary Viewer</h1>
        
        <div id="message" class="message">Loading dictionary...</div>
        
        <div class="controls" id="controls" style="display: none;">
            <div class="controls-left">
                <div class="control-group">
                    <label for="wordSearch">Search Words:</label>
                    <input type="text" id="wordSearch" placeholder="Search in words...">
                </div>
                
                <div class="control-group">
                    <label for="definitionSearch">Search Definitions:</label>
                    <input type="text" id="definitionSearch" placeholder="Search in definitions...">
                </div>
            </div>
            
            <div class="controls-right">
                <div class="pagination">
                    <button id="prevPage">‚Üê Prev</button>
                    <div class="page-info" id="pageInfo">Page 1 of 1</div>
                    <button id="nextPage">Next ‚Üí</button>
                </div>
            </div>
        </div>

        <div class="stats" id="stats" style="display: none;">
            <div class="stat">Total Words: <span id="totalCount">0</span></div>
            <div class="stat">Filtered: <span id="filteredCount">0</span></div>
            <div class="stat">Showing: <span id="displayedCount">0</span></div>
            <div class="stat">Average Length: <span id="avgLength">0</span></div>
        </div>

        <div class="table-container" id="tableContainer" style="display: none;">
            <table>
                <thead>
                    <tr>
                        <th class="sortable" data-column="word">Word</th>
                        <th class="sortable" data-column="length">Length</th>
                        <th>Definition</th>
                        <th class="sortable" data-column="deck">Deck</th>
                    </tr>
                </thead>
                <tbody id="dictionaryTable">
                </tbody>
            </table>
        </div>
    </div>

    <script>
        class DictionaryViewer {
            constructor() {
                this.data = [];
                this.filteredData = [];
                this.currentSort = { column: 'word', order: 'asc' };
                this.currentPage = 1;
                this.itemsPerPage = 100;
                this.init();
            }

            init() {
                this.bindEvents();
                this.tryAutoLoad();
            }

            async tryAutoLoad() {
                try {
                    this.showMessage('Loading dictionary...', 'loading');
                    
                    // Get current location to determine correct path
                    const currentPath = window.location.pathname;
                    console.log('Current URL:', window.location.href);
                    console.log('Current path:', currentPath);
                    
                    // Determine the correct path based on current location
                    let xmlPath;
                    if (currentPath.includes('/utility/')) {
                        // We're in utility folder, go up one level
                        xmlPath = '../dictionary/word_decks.xml';
                        console.log('Detected utility folder location, using:', xmlPath);
                    } else {
                        // We're in root folder
                        xmlPath = 'dictionary/word_decks.xml';
                        console.log('Detected root folder location, using:', xmlPath);
                    }
                    
                    console.log(`Attempting to load: ${xmlPath}`);
                    const response = await fetch(xmlPath);
                    console.log(`Response:`, response.status, response.statusText);
                    
                    if (response.ok) {
                        const xmlText = await response.text();
                        console.log(`‚úÖ Successfully loaded XML file`);
                        console.log(`File size: ${xmlText.length} characters`);
                        console.log(`First 200 chars:`, xmlText.substring(0, 200));
                        
                        this.processDictionaryXML(xmlText);
                        this.showSuccess(`Successfully loaded ${this.data.length} entries`);
                        this.showTable();
                        this.sortAndRender();
                    } else {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                } catch (error) {
                    console.log('‚ùå Auto-load failed:', error.message);
                    this.showMessage(`Auto-load failed: ${error.message}. Please use file upload.`, 'error');
                }
            }

            bindEvents() {
                // Search filters with debounce for better performance
                let wordSearchTimeout, defSearchTimeout;
                
                document.getElementById('wordSearch').addEventListener('input', (e) => {
                    clearTimeout(wordSearchTimeout);
                    wordSearchTimeout = setTimeout(() => {
                        this.filterData();
                    }, 300);
                });
                
                document.getElementById('definitionSearch').addEventListener('input', (e) => {
                    clearTimeout(defSearchTimeout);
                    defSearchTimeout = setTimeout(() => {
                        this.filterData();
                    }, 300);
                });

                // Pagination controls
                document.getElementById('prevPage').addEventListener('click', () => {
                    if (this.currentPage > 1) {
                        this.currentPage--;
                        this.renderTable();
                    }
                });

                document.getElementById('nextPage').addEventListener('click', () => {
                    const maxPages = Math.ceil(this.filteredData.length / this.itemsPerPage);
                    if (this.currentPage < maxPages) {
                        this.currentPage++;
                        this.renderTable();
                    }
                });

                // Table header clicks
                document.querySelectorAll('th.sortable').forEach(th => {
                    th.addEventListener('click', () => {
                        const column = th.dataset.column;
                        if (this.currentSort.column === column) {
                            this.currentSort.order = this.currentSort.order === 'asc' ? 'desc' : 'asc';
                        } else {
                            this.currentSort.column = column;
                            this.currentSort.order = 'asc';
                        }
                        this.updateSortControls();
                        this.sortAndRender();
                    });
                });
            }

            async loadDictionaryFromFile(file) {
                // This method is no longer needed since we removed manual upload
                console.log('Manual file loading disabled - using auto-load only');
            }

            processDictionaryXML(xmlText) {
                try {
                    console.log('Parsing XML...');
                    
                    // Clean up namespace issues before parsing
                    let cleanXml = xmlText.replace(/deck:All/g, 'deck');
                    
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(cleanXml, 'text/xml');
                    
                    // Check for XML parsing errors
                    const parseError = xmlDoc.querySelector('parsererror');
                    if (parseError) {
                        // Try original XML if cleaning didn't work
                        const originalDoc = parser.parseFromString(xmlText, 'text/xml');
                        const originalError = originalDoc.querySelector('parsererror');
                        if (originalError) {
                            throw new Error('Invalid XML format - please regenerate word_decks.xml with updated deck_maker.py');
                        }
                        // Use original if it works
                        console.log('XML parsed successfully with original format');
                        this.parseXML(originalDoc);
                    } else {
                        console.log('XML parsed successfully with cleaned format');
                        this.parseXML(xmlDoc);
                    }
                } catch (error) {
                    console.error('XML processing error:', error);
                    throw error;
                }
            }

            parseXML(xmlDoc) {
                console.log('Extracting entries...');
                const entries = xmlDoc.querySelectorAll('entry');
                console.log('Found entries:', entries.length);
                
                this.data = [];

                entries.forEach((entry, index) => {
                    try {
                        const wordEl = entry.querySelector('word');
                        const defEl = entry.querySelector('definition');
                        
                        // Try multiple ways to find deck element
                        let deckEl = entry.querySelector('deck') ||           // New format
                                   entry.querySelector('deck\\:All') ||       // Old format (escaped)
                                   entry.querySelector('[*|All]') ||          // Namespace wildcard
                                   null;
                        
                        const word = wordEl ? wordEl.textContent.trim() : '';
                        const definition = defEl ? defEl.textContent.trim() : '';
                        const deck = deckEl ? deckEl.textContent.trim() : 'N/A';

                        if (word && definition) {
                            this.data.push({ word, definition, deck });
                        } else {
                            console.log(`Entry ${index} missing data:`, { word, definition, deck });
                        }
                    } catch (error) {
                        console.error(`Error processing entry ${index}:`, error);
                    }
                });

                this.filteredData = [...this.data];
                console.log(`Successfully parsed ${this.data.length} dictionary entries`);
                
                if (this.data.length === 0) {
                    throw new Error('No valid entries found in XML file');
                }
            }

            filterData() {
                const wordTerm = document.getElementById('wordSearch').value.toLowerCase().trim();
                const defTerm = document.getElementById('definitionSearch').value.toLowerCase().trim();
                
                console.log(`Starting search - Word: "${wordTerm}", Definition: "${defTerm}"`);
                console.log(`Total data entries: ${this.data.length}`);
                
                if (!wordTerm && !defTerm) {
                    // No search terms - show all data
                    this.filteredData = [...this.data];
                    console.log(`No search terms - showing all ${this.filteredData.length} entries`);
                } else {
                    // Filter based on both search terms
                    this.filteredData = this.data.filter(entry => {
                        let wordMatch = true;
                        let defMatch = true;
                        
                        // If word search term exists, entry must match it
                        if (wordTerm) {
                            wordMatch = entry.word && entry.word.toLowerCase().includes(wordTerm);
                        }
                        
                        // If definition search term exists, entry must match it
                        if (defTerm) {
                            defMatch = entry.definition && entry.definition.toLowerCase().includes(defTerm);
                        }
                        
                        // Entry must match BOTH conditions (AND logic)
                        return wordMatch && defMatch;
                    });
                    
                    console.log(`Search results: ${this.filteredData.length} out of ${this.data.length} total entries`);
                    console.log(`Word filter: "${wordTerm}" ${wordTerm ? '‚úì' : '‚óã'}`);
                    console.log(`Definition filter: "${defTerm}" ${defTerm ? '‚úì' : '‚óã'}`);
                    
                    // Show some examples of matches for small result sets
                    if (this.filteredData.length > 0 && this.filteredData.length <= 10) {
                        console.log('Matches found:', this.filteredData.map(e => e.word));
                    }
                }
                
                this.currentPage = 1; // Reset to first page when filtering
                this.sortAndRender();
            }

            sortData() {
                this.filteredData.sort((a, b) => {
                    let aValue, bValue;

                    if (this.currentSort.column === 'length') {
                        // Sort by word length (numeric)
                        aValue = a.word.length;
                        bValue = b.word.length;
                    } else {
                        // Sort by text (case-insensitive)
                        aValue = (a[this.currentSort.column] || '').toLowerCase();
                        bValue = (b[this.currentSort.column] || '').toLowerCase();
                    }

                    let comparison = 0;
                    if (aValue < bValue) comparison = -1;
                    else if (aValue > bValue) comparison = 1;

                    return this.currentSort.order === 'desc' ? -comparison : comparison;
                });
            }

            renderTable() {
                const tbody = document.getElementById('dictionaryTable');
                tbody.innerHTML = '';

                // Calculate pagination
                const startIndex = (this.currentPage - 1) * this.itemsPerPage;
                const endIndex = startIndex + this.itemsPerPage;
                const pageData = this.filteredData.slice(startIndex, endIndex);

                // Render current page data
                pageData.forEach(entry => {
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td class="word">${this.escapeHtml(entry.word)}</td>
                        <td style="text-align: center; font-weight: 600; color: #667eea;">${entry.word.length}</td>
                        <td class="definition">${this.escapeHtml(entry.definition)}</td>
                        <td><span class="deck">${this.escapeHtml(entry.deck)}</span></td>
                    `;
                    tbody.appendChild(row);
                });

                this.updateStats();
                this.updateSortHeaders();
                this.updatePagination();
            }

            updateStats() {
                const startIndex = (this.currentPage - 1) * this.itemsPerPage;
                const endIndex = Math.min(startIndex + this.itemsPerPage, this.filteredData.length);
                
                document.getElementById('totalCount').textContent = this.data.length;
                document.getElementById('filteredCount').textContent = this.filteredData.length;
                document.getElementById('displayedCount').textContent = `${startIndex + 1}-${endIndex}`;
                
                const avgLength = this.filteredData.length > 0 
                    ? (this.filteredData.reduce((sum, entry) => sum + entry.word.length, 0) / this.filteredData.length).toFixed(1)
                    : 0;
                document.getElementById('avgLength').textContent = avgLength;
            }

            updatePagination() {
                const maxPages = Math.ceil(this.filteredData.length / this.itemsPerPage);
                const prevBtn = document.getElementById('prevPage');
                const nextBtn = document.getElementById('nextPage');
                const pageInfo = document.getElementById('pageInfo');

                prevBtn.disabled = this.currentPage <= 1;
                nextBtn.disabled = this.currentPage >= maxPages;
                pageInfo.textContent = `Page ${this.currentPage} of ${maxPages}`;
            }

            updateSortHeaders() {
                document.querySelectorAll('th.sortable').forEach(th => {
                    th.classList.remove('sort-asc', 'sort-desc');
                    if (th.dataset.column === this.currentSort.column) {
                        th.classList.add(`sort-${this.currentSort.order}`);
                    }
                });
            }

            updateSortControls() {
                // Sort controls removed - sorting handled by header clicks only
            }

            sortAndRender() {
                this.sortData();
                this.currentPage = 1; // Reset to first page when sorting
                this.renderTable();
            }

            showTable() {
                document.getElementById('controls').style.display = 'flex';
                document.getElementById('stats').style.display = 'flex';
                document.getElementById('tableContainer').style.display = 'block';
            }

            showMessage(message, type = 'message') {
                const messageEl = document.getElementById('message');
                messageEl.textContent = message;
                messageEl.className = type === 'error' ? 'error' : type === 'loading' ? 'message' : 'message';
                messageEl.style.display = 'block';
            }

            showSuccess(message) {
                const messageEl = document.getElementById('message');
                messageEl.textContent = message;
                messageEl.className = 'success';
                messageEl.style.display = 'block';
                setTimeout(() => {
                    messageEl.style.display = 'none';
                }, 3000);
            }

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', () => {
            new DictionaryViewer();
        });
    </script>
</body>
</html>